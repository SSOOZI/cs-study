## 플린 분류법

> 컴퓨터 시스템의 **명령어 스트림(Instruction Stream)과 데이터 스트림(Data Stream)**의 개수를 기준으로 `병렬 처리 구조`를 분류한 방법입니다.
> 
- 1972년 마이클 플린이 제안한 분류법입니다.

**명령어 스트림**

- 동시에 실행되는 명령어 흐름의 개수
- CPU가 실행하는 명령어들의 흐름
- 프로그램 카운터(PC)가 가리키는 명령어가 순차적으로 흘러가는 것

→ 즉, 지금 CPU가 어떤 명령어를 실행하고 있는가?

```
ADD R1, R2
MUL R3, R4
LOAD R5, 100
```

- 이 명령어들의 `실행 흐름이 하나`라면 → `1개의 명령어 스트림`입니다.
- 만약 여러 개의 CPU가 각각 다른 명령어를 실행하고 있다면 → 여러 개의 명령어 스트림이 생깁니다.

**데이터 스트림**

- 동시에 처리되는 데이터 흐름의 개수
- 명령어가 처리하는 실제 데이터의 흐름
- 메모리에서 읽거나 레지스터에서 가져와서 연산되는 데이터 값들이 흐르는 것을 의미

→ 즉, 명령어가 지금 어떤 데이터를 가져와서 처리하고 있는가?

```
ADD R1, R2   → 데이터 스트림 = (R1값, R2값)
MUL R3, R4   → 데이터 스트림 = (R3값, R4값)
```

- 하나의 명령어가 `하나의 데이터`만 다룬다면 → `1개의 데이터 스트림`
- 하나의 명령어가 동시에 여러 데이터(벡터, 행렬 등)를 다룬다면 → 여러 개의 데이터 스트림

<br/>

**플린 분류법의 4가지 구조**

1. **SISD (Single Instruction stream, Single Data stream)**
    - 단일 명령어가 단일 데이터를 처리하는 구조입니다.
        
        ```
        C[i] = A[i] + B[i] (i=1~100)
        
        C[1] = A[1] + B[1]
        C[2] = A[2] + B[2]
        -> 한 번에 한 데이터만 처리
        ```
        
        - 명령어 하나가 데이터 하나를 순차적으로 처리합니다.
    - 전통적인 폰 노이만 구조를 따릅니다.
    - 병렬성이 없으며 순차적으로 처리됩니다.
    - ex) 일반적인 단일 코어 CPU
    
2. **SIMD (Single Instruction stream, Multiple Data stream)**
    - 단일 명령어 스트림과 다중 데이터 스트림으로 이루어진 구조입니다.
        
        ```
        C[i] = A[i] + B[i] (i=1~100)
        
        C[1~4] = A[1~4] + B[1~4]
        -> 동일 명령어가 여러 데이터를 동시에 처리
        ```
        
        - 같은 명령어가 여러 데이터를 동시에 처리합니다.
    - 벡터 연산이나 행렬 연산, 그래픽 처리 등 데이터 병렬성이 큰 작업에 적합합니다.
    - ex) GPU, 벡터 프로세서, 배열 프로세서 등..
3. **MISD (Multiple Instruction stream, Single Data stream)**
    - 다중 명령어 스트림과 단일 데이터 스트림으로 이루어진 구조입니다.
        
        ```
        데이터 X → 명령어1(필터링), 명령어2(암호화), 명령어3(압축)
        → 여러 명령어가 같은 데이터에 동시에 적용
        ```
        
        - 여러 명령어가 하나의 데이터에 순차적 혹은 동시에 적용됩니다.
    - 실제로는 거의 사용되지 않는 구조
        - 특수한 신호 처리 시스템에서 일부 사용
        - 같은 데이터를 여러 알고리즘으로 동시에 검사해서 오류 감지/복구
4. **MIMD (Multiple Instruction stream, Multiple Data stream)**
    - 다중 명령어 스트림과 다중 데이터 스트림으로 이루어진 구조입니다.
        
        ```
        CPU1 → C[1~50] = A[1~50] + B[1~50]
        CPU2 → C[51~100] = A[51~100] + B[51~100]
        → 서로 다른 명령어/데이터를 독립적으로 실행
        -> 각 프로세스가 자기 명령어를 실행하고, 자기 데이터를 처리
        ```
        
        - 여러 명령어가 여러 데이터를 동시에 처리하는 일반적인 병렬 컴퓨터 구조입니다.
    - 프로세서 간 독립성이 있으며, 명령어 병렬성과 데이터 병렬성을 모두 활용합니다.
    - 대표적인 예시
        - SMP (Symmetric Multiprocessing)
            - 동일한 메모리를 공유하며 CPU 간 대칭 구조를 가집니다. (대칭 다중 프로세서)
            - 모든 CPU가 같은 메모리에 접근 가능
            - 각 CPU가 독립적으로 실행 가능
            - 왜 공유 메모리를 사용할까?
                1. 데이터의 일관성을 유지하기 쉽다
                    - CPU1과 CPU2가 같은 변수를 다룰 때, 공유 메모리면 항상 최신 데이터를 볼 수 있습니다.
                    - 예를 들어,
                        - CPU1이 x = 5로 바꿨다면
                        - CPU2도 같은 메모리 공간에서 x를 읽을 수 있습니다.
                2. 운영체제가 관리하기 편리하다
                    - 프로세스 간 통신(IPC)이 쉬워집니다.
                    - 복잡한 네트워크 통신이나 메시지 패싱이 필요없습니다.
                3. 단일 시스템 이미지를 제공한다
                    1. OS 입장에서 CPU가 여러 개가 있어도 하나의 시스템처럼 동작합니다.
                    2. 일반 프로그램은 멀티코어인지 몰라도 그대로 실행 가능
                
                장점
                
                - 데이터 공유/일관성 유지가 쉽다
                - 프로그래밍/OS 관리가 단순
                
                단점
                
                - CPU가 많아지면 메모리 접근 경합이 심해짐 → 메모리 병목 현상 발생
                - 그래서 CPU 수가 일정 수준 이상 늘어나면 성능 한계 발생
            - 비유
                - 한 집에 있는 여러 명이 같은 냉장고를 씀
                - 누구나 음식(데이터)을 꺼내서 먹음
                - 관리는 편하지만, 사람이 많으면 냉장고 앞에서 줄서기 발생
        - NUMA (Non-Uniform Memory Access)
            - 메모리 접근 속도가 위치에 따라 달라집니다. (비균일 메모리 접근)
            - CPU마다 자기 전용 메모리가 존재
            - 다른 CPU 메모리에 접근은 가능하지만 속도가 느림
            - 비유
                - 방마다 냉장고가 따로 있음
                - 기본적으로 자기 냉장고를 쓰지만, 다른 방 냉장고에도 갈 수 있음
                - 멀리 가서 꺼내오면 시간 더 걸림
        - 클러스터
            - 독립된 시스템을 네트워크로 연결하여 동작합니다. (즉, 여러 독립된 컴퓨터(노드)를 네트워크로 묶어 하나의 시스템처럼 사용)
            - 각 노드가 자기 메모리와 자기 디스크를 가짐
