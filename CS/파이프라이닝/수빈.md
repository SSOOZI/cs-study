- [🧠 파이프라이닝이란?](#-파이프라이닝이란)
  - [📍 명령어 처리 과정](#-명령어-처리-과정)
  - [🚧 파이프라이닝 구조](#-파이프라이닝-구조)
  - [⚠️ 파이프라이닝의 문제점](#️-파이프라이닝의-문제점)

---

## 🧠 파이프라이닝이란?

파이프라이닝은 `컴퓨터 명령어 처리 과정을 여러 단계`로 나누고, 각 단계마다 `병렬`로 처리하여 CPU의 처리 효율을 향상시키는 기술입니다.

> 즉, 하나의 명령어가 처리되는 동안 다른 명령어도 동시에 처리되도록 합니다.

<br>

### 📍 명령어 처리 과정

1. IF(Instruction Fetch) : 명령어를 메모리에서 가져옴
2. ID(Instruction Decode) : 명령어 해석 및 레지스터 값 읽기
3. EX(Execute) : 연산 수행 또는 주소 계산
4. MEM(Memory access) : 메모리 접근 (필요 시)
5. WB(Write Back) : 연산 결과를 레지스터에 저장

> 파이프라이닝은 이 단계들을 동시에 실행함으로써 처리량(Throughput)을 증가시킵니다.

<br>

### 🚧 파이프라이닝 구조

| Cycle | 명령어1 | 명령어2 | 명령어3 | 명령어4 | 명령어5 |
| ----- | ------- | ------- | ------- | ------- | ------- |
| 1     | IF      |         |         |         |         |
| 2     | ID      | IF      |         |         |         |
| 3     | EX      | ID      | IF      |         |         |
| 4     | MEM     | EX      | ID      | IF      |         |
| 5     | WB      | MEM     | EX      | ID      | IF      |
| 6     |         | WB      | MEM     | EX      | ID      |
| 7     |         |         | WB      | MEM     | EX      |
| 8     |         |         |         | WB      | MEM     |
| 9     |         |         |         |         | WB      |

- 하나의 명령어는 여전히 5 사이클이 필요하지만, **5개의 명령어를 9 사이클만에 처리**할 수 있게 됩니다.

<details>
<summary> 👀 파이프라이닝이 아닐 경우, 명령어 실행 순서 보기</summary>

| Cycle | 명령어1 | 명령어2 | 명령어3 | 명령어4 | 명령어5 |
| ----- | ------- | ------- | ------- | ------- | ------- |
| 1     | IF      |         |         |         |         |
| 2     | ID      |         |         |         |         |
| 3     | EX      |         |         |         |         |
| 4     | MEM     |         |         |         |         |
| 5     | WB      |         |         |         |         |
| 6     |         | IF      |         |         |         |
| 7     |         | ID      |         |         |         |
| 8     |         | EX      |         |         |         |
| 9     |         | MEM     |         |         |         |
| 10    |         | WB      |         |         |         |
| 11    |         |         | IF      |         |         |
| ...   | ...     | ...     | ...     | ...     | ...     |

- 각 명령어가 완료된 후에야 다음 명령어가 시작되므로, 5개 명령어를 처리하는 데 **최대 25 사이클**이 걸립니다.
</details>

<br>

### ⚠️ 파이프라이닝의 문제점

파이프라이닝의 문제점이 발생하는 근본적인 원인은 **동시에 여러 명령어를 병렬로 실행**하기 때문입니다.
파이프라이닝은 명령어들을 단계별로 분할하여 서로 겹쳐서 실행합니다.
이 과정에서 서로 영향을 미치는 명령어들이 동시에 실행되면, 아래와 같은 충돌이나 원인이 발생할 수 있습니다.

**자료(데이터) 해저드**

- 이전 명령어의 결과가 다음 명령어에 영향을 미칠 때 발생
  - ex) 이전 명령어의 실행 결과가 아직 나오지 않았는데, 그 결과를 사용하려는 다음 명령어가 먼저 실행될 때
- 해결법
  - 데이터 포워딩 : 연산 결과를 바로 다음 단계로 넘겨주는 방식 (`WB`까지 기다리지 않음)
  - 파이프라인 스톨 : 명령어 실행을 잠시 멈춰서 기다림
  - 레지스터 리네이밍 : 서로 다른 레지스터를 사용하도록 하여 충돌을 방지

**제어 해저드**

- 분기 명령어(branch)의 결과에 따라 다음 명령어 흐름이 달라질 때
  - ex) 분기 명령어의 결과가 나오기 전 명령어를 미리 실행해서 생기는 문제
- 해결법
  - 분기 예측 : 분기가 일어날지를 CPU가 예측해서 실행, 예측이 실패하면 롤백
  - 지연 분기 : 분기 후 실행할 명령어를 미리 한두 개 정해서 넣어두는 방식
  - 파이프라인 플러시 : 예측이 틀렸을 때, 잘못된 명령어를 모두 폐기하고 다시 수행

**구조 해저드**

- 동일한 하드웨어 자원을 여러 명령어가 동시에 요구할 때
  - ex) 두 명령어가 동시에 메모리에 접근하려고 할 때
  - ex) CPU 설계가 단일 메모리 구조를 쓸 경우 -> 자원 충돌
- 해결법
  - 하드웨어 자원 복제(자원 이중화) : 명령어 메모리와 데이터 메모리를 분리
  - 자원 접근 스케줄링 : 자원 충돌이 나지 않도록 타이밍을 조절
  - 파이프라일 스톨 : 한 명령어가 자원을 사용한 후 다음 명령어가 접근하도록 대기
