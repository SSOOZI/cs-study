## 🧠 캐시 메모리와 연관 사상 방식

캐시 메모리는 CPU와 메인 메모리 사이의 속도 차이를 줄이기 위해 사용하는 고속 메모리입니다.
CPU는 자주 사용하는 데이터를 캐시에 저장해 성능을 향상시킵니다.

이때, **메인 메모리 블록을 캐시 어디에 저장할지**를 결정하는 방식이 `매빙 방식` 입니다.

<br>

### 📌 캐시 매핑 방식 종류

| 방식           | 설명                                                                 |
| -------------- | -------------------------------------------------------------------- |
| 직접 사상      | 메모리 블록이 캐시의 **한 위치**에만 저장됨 (`주소 % 캐시라인수`)    |
| 완전 연관 사상 | 메모리 블록이 **캐시 어디든** 저장 가능                              |
| 집합 연관 사상 | 캐시를 **여러 집합 set**으로 나누고, 블록은 해당 집합 내 어디든 저장 |

<br>

### 🔍 직접 사상 (Direct Mapping)

메인 메모리의 각 블록이 캐시의 단 하나의 고정된 라인에만 저장될 수 있는 방식입니다.

**🧩 특징**

- 메모리 블록 번호에 `mod 연산`을 적용하여 저장될 캐시 라인을 결정합니다.

  - ex) `블록 번호 mod 캐시 라인 수`의 결과가 5라면, 메인 메모리의 블록이 복사되어 캐시의 5번 라인에만 저장될 수 있습니다.

- 캐시 내에서 하나의 메모리 블록은 **오직 한 위치**에만 저장되므로, 구현이 간단하고 접근 속도가 빠릅니다.

- 단점으로는 서로 다른 블록이 동일한 캐시 라인에 매핑되는 경우(충돌이 일어하는 경우), 빈 라인이 많더라도 덮어쓰기가 발생할 수 있습니다.

**🔧 주소 구조**

직접 사상 방식에는 메모리 주소를 다음과 같이 분할하여 사용합니다.

```
| Tag | Index | Offset |
```

- Offset

  - 해당 블록 내의 데이터 위치를 결정합니다.

- Index

  - 전체 캐시 라인 중 어느 라인에 접근할지 결정합니다.

- Tag

  - 해당 라인에 저장된 데이터가 어떤 메모리 블록인지 식별하는데 사용됩니다.

**💭 예시**

- 메모리 크기: 64KB (2^16 바이트 → 주소 16비트)
- 캐시 크기: 1KB = 1024바이트
- 블록 크기: 16바이트
  → 캐시 라인 수 = 1024 / 16 = 64줄 (2^6)

주소 16비트를 다음과 같이 분할

- Offset: 4비트 (16바이트 블록 → 2⁴)
- Index: 6비트 (64줄 → 2⁶)
- Tag: 나머지 6비트 (16 - 6 - 4 = 6)

**⚙️ 작동 방식**

1. CPU가 메모리 주소 A에 접근합니다.
2. 주소 A에서 Index를 추출하여 해당 캐시 라인을 찾습니다. 3. 해당 캐시 라인에 저장된 Tag와 주소 A의 Tag를 비교합니다.
   - 일치 → 캐시 Hit → 즉시 데이터 사용
   - 불일치 → 캐시 Miss → 메모리에서 데이터 로드 후 캐시 갱신

<br>

### 🔍 완전 연관 사상 (Fully Associative Mapping)

메인 메모리의 각 블록이 **캐시의 어느 위치에나 자유롭게 저장될 수 있는 방식**입니다.

**🧩 특징**

- 메모리 블록은 캐시의 모든 라인 중 아무 곳에나 저장될 수 있습니다.
- 저장할 위치가 고정되어 있지 않기 때문에, 충돌이 발생할 확률이 낮고 캐시 공간을 유연하게 사용할 수 있습니다.
- 반면, CPU가 데이터를 찾기 위해 모든 캐시 라인의 Tag를 일일이 비교해야 하므로, 하드웨어 구현이 복잡하고 시간이 더 걸릴 수 있습니다.

**🔧 주소 구조**

완전 연관 사상 방식은 캐시 라인이 고정되어 있지 않기 때문에, `Index`가 필요 없습니다.

```
| Tag | Offset |
```

- Offset

  - 해당 블록 내에서의 데이터 위치를 지정합니다.

- Tag
  - 어떤 메모리 블록인지 식별하는 값입니다.
  - 캐시의 모든 라인의 Tag와 비교하여 일치 여부를 판단합니다.

**⚙️ 작동 방식**

1. CPU가 메모리 주소 A에 접근합니다.
2. 캐시의 모든 라인의 Tag와 주소 A의 Tag를 동시에 비교합니다.
3. 일치하는 Tag가 있다면 → 캐시 Hit → Offset을 통해 원하는 데이터에 접근합니다.
4. 일치하는 Tag가 없다면 → 캐시 Miss → 메모리에서 블록을 읽어와 캐시의 빈 라인 또는 교체 정책에 따라 라인 교체 후 저장합니다.

<br>

### 🔍 집합 연관 사상 (Set Associative Mapping)

직접 사상과 완전 연관 사상의 절충형으로 메모리 블록을 캐시의 특정 `집합 set`에만 저장하되, 해당 집합 내에서는 자유롭게 저장할 수 있는 방식입니다.

**🧩 특징**

- 전체 캐시를 여러 집합(set)으로 나누고, 각 집합은 여러 개의 캐시 라인을 가집니다.
- 메모리 블록은 고정된 집합에만 매핑되지만, 해당 집합 안에서는 어느 라인에든 저장될 수 있습니다.
- 일반적으로 `n-방향 집합 연관 사상`라고 하며, n은 각 집합에 포함된 라인 수를 의미합니다.
  - ex) `4-way`: 각 집합에 4개의 캐시 라인이 존재합니다.
- 충돌 가능성이 직접 사상보다 적고, 완전 연관 사상보다 구현이 단순합니다.
