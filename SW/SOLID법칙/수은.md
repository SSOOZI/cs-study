✅ SOLID란?
SOLID는 객체지향 프로그래밍에서 유지보수와 확장성이 좋은 소프트웨어를 설계하기 위한 5가지 원칙의 약자입니다.

S - SRP: 단일 책임 원칙
O - OCP: 개방-폐쇄 원칙
L - LSP: 리스코프 치환 원칙
I - ISP: 인터페이스 분리 원칙
D - DIP: 의존관계 역전 원칙

1. SRP – 단일 책임 원칙 (Single Responsibility Principle)
"클래스는 오직 하나의 책임만 가져야 한다"

한 클래스는 하나의 역할만 해야 하고, 변경 이유도 하나여야 함.

여러 책임이 섞이면, 하나만 바꿔도 다른 기능이 영향받을 수 있음.

📌 예시:
ReportPrinter 클래스가 문서 출력도 하고 저장도 하고 계산도 한다면 → 역할을 분리해야 함.

2. OCP – 개방-폐쇄 원칙 (Open-Closed Principle)
"확장에는 열려 있고, 수정에는 닫혀 있어야 한다"

새로운 기능을 추가할 때 기존 코드를 수정하지 않고 확장할 수 있어야 함.

다형성과 추상화를 잘 활용하면 가능.

📌 예시:
할인 정책을 바꿀 때 DiscountPolicy 인터페이스를 구현한 새로운 클래스를 추가하면 기존 코드는 수정할 필요 없음.

3. LSP – 리스코프 치환 원칙 (Liskov Substitution Principle)
"부모 클래스 객체는 자식 클래스 객체로 대체할 수 있어야 한다"

자식 클래스가 부모 클래스의 기능을 올바르게 확장해야 함.

자식이 부모 대신 사용돼도 프로그램이 문제 없이 작동해야 함.

📌 예시:
Bird라는 부모 클래스가 있고 Penguin이 상속받는다면, Penguin.fly()가 존재해서 오류가 나는 건 위반.

4. ISP – 인터페이스 분리 원칙 (Interface Segregation Principle)
"사용하지 않는 인터페이스에 의존하지 않도록 나누어야 한다"

클라이언트는 필요한 기능만 가진 인터페이스만 알아야 함.

큰 인터페이스보단 작고 명확한 인터페이스 여러 개가 좋음.

📌 예시:
Animal 인터페이스에 fly()가 포함되면, 날지 않는 동물(Dog)도 구현해야 하므로 불필요. → 나눠야 함.

5. DIP – 의존관계 역전 원칙 (Dependency Inversion Principle)
"구체 클래스가 아닌 추상(인터페이스)에 의존하라"

고수준 모듈(비즈니스 로직)이 저수준 모듈(구현)에 의존하지 않도록 해야 함.

둘 다 인터페이스(추상화) 에 의존하게 하면 결합도가 낮아지고 유연해짐.

📌 예시:
OrderService가 KakaoPayService를 직접 사용하는 게 아니라, PaymentService 인터페이스를 사용해야 유연해짐.
